I. Source Code 품질 분석 도구
1. 정의 -> Source Code 에 대한 Coding Style, 설정된 Coding 표준, Code 복잡도, Code 내 존재하는 메모리 누수 현황, Thread 결함 발견하기 위해 사용하는 분석 도구]
2. 정적 분석 도구
- 1. 작성된 Source Code 실행시키지 않고, Coding 표준, Code 복잡도, Code Style 적정 여부, 잔존 결함 발견 여부 확인
- 2. Code Inspection -> Source Code 대상, 결함 발견

** 표 구분
- 1. 정적 분석 도구
  = 1. PMD -> Java 및 타 언어 Source Code 에 대한 Bug, Dead Code 분석 (Linux, Windows)
  = 2. CppCheck -> C/C++ Code Memory 누수, Overflow 등 문제 분석 (Windows)
  = 3. SonarQube -> Source Code 품질 통합 Platform, Plug-In 확장 (Cross-Platform)
  = 4. CheckStyle -> Java Code Coding 표준 준수 검사 도구 (Cross-Platform)

- 2. Code 복잡도
  = 1. CCM -> 다양한 언어의 Code 복잡도 분석 도구, Linux, Mac 환경 CLI (Cross-Platform)
  = 2. Cobertura -> jcoverage 기반 Test Coverage (Test 검증 기준) 측정 도구 (Cross-Platform)

** Test Coverage 측정 도구
- 1. Test 가능한 경로 중 Test 도구 통해 Test 된 Coverage 측정
- 2. 종류 -> Clover, JCoverage, ElcEmma

3.동적 분석 도구
- 1. Application 실행, Memory 누수 현황 발견, Thread 결함 분석
- 2. Avalanche -> Valgrind Framework 및 STP 기반 S/W Error 및 취약점 (Linux, Android)
- 3. Valgrind -> 자동화된 Memory 및 Thread 결함 발견 분석 도구 (Cross-Platform)

** Memory 누수 (Memory Leak)
- Computer Program 이 필요하지 않은 Memory 를 계속 점유하고 있는 현상

** Thread
- Process 내 작업 단위 (CPU 가 독립적으로 처리하는 하나의 작업 단위) -> 병행성 증대


II. Code Inspection
1. 정의 및 특징
- 1. Source Code 를 대상으로 결함 발견 (정적 분석 기법)
- 2. Code 작성 규칙 기반으로 Source Code 점검, 작성 규칙에 위반되는 Source Code 를 추출하는 분석 도구 (주민등록번호 Hard Coding 위반)
- 3. Build 도구 연계하여 Build, Deploy 수행 시 자동적으로 점검 가능
- 4. 설계 및 설계 산출물까지 포괄 = S/W Inspection
- 5. 기능적으로 이상없는 Source Code 대상으로 검증 (표준 준수하지 않은 Code 는 잠재적 오류 발생 가능성 있음)
- 6. Error 90% 까지 찾아낼 수 있음
- 7. 개발 전체 수명 주기 Resource 절감, 비용 감소, 산출물의 품질 향상
- 8. 제품의 재공학 (Re-Engineering)

** 재공학 (Re-Engineering)
- 1. 기존 System 이용, 보다 나은 System 구축, 새로운 기능 추가하여 S/W 성능 향상
- 2. 기존 S/W 파기 X, 변경된 사용자 요구사항, 수정된 환경으로 기존 S/W 수정 보완하여 재구축
 
2. Code Inspection Rule 유형
- 1. 성능 개선 -> Application 성능에 영향 미칠 수 있는 Code 점검 => Memory 누수, 미사용 변수 / Method 여부
- 2. Code 작성 규칙 -> 명명규칙 준수 여부 점검, 미 준수한 Code 내역 추출, Source Code 가독성 향상
- 3. Error 발생 가능성이 있는 Code 점검하는 Rule

3. Code 작성 Rule 심각도 구분 예시
- 1. 필수 -> 반드시 수정되어야 하는 위반 사항, Error 발생 가능성 매우 높고, Memory 누수 발생되는 Code
- 2. 권고 상 (Critical) -> Error 발생 가능성 높고, 일반적으로 수정되어야 하는 심각한 위반 사항
- 3. 권고 중 (Major) -> Error 발생, 수정 권고하는 중요 위반 사항
- 4. 권고 하 (Minor) -> Source Code 가독성, 유지보수성 향상
- 5. 정보 (Info) -> 정보성 제공 위반 사항 (개발자 참고하여 적용)

4. 정규 표현식 (Regular Expression 정규식)
- 1. 특정 규칙을 가진 문자열의 집합 표현 -> 복잡한 문자열 처리할 때 사용
- 2. 기본 문법 예시
  = 1. `.` - 문자
    -> 1. 임의의 1개의 문자와 일치
    -> 2. ex. 1.1 : 1A1, 1b1, 1@1, 151

  = 2. `|` - 선택
    -> 1. 여러 식 중 하나 선택 (또는)
    -> 2. ex. abc|adc : abc, adc
  
  = 3. `[]` - 문자 Class
    -> 1. "[" 와 "]" 사이 문자들 연결
    -> 2. ex. [abc]d : ad, bd, cd
    -> 3. "-" 기호와 함께 쓰면 범위 지정 가능
    -> 4. ex. [1-9] : 1 ~ 9까지 중 하나의
  
  = 4. [^] - 부정
    -> 1. "[" 와 "]" 사이 문자 제외한 나머지 선택
    -> 2. ex. [^abc]d : ad. bd, cd 포함 X, ed, fd 등 포함 O
    -> 3. [^a-z] : Alphabet 소문자로 시작하지 않는 모든 문자 의미

  = 5. ^ - 처음
    -> 1. 문자열 행의 처음
    -> 2. ex. ^linux : linux 로 시작하는 모든 문자열이나 행
